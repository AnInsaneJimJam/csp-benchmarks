use circuit_std_rs::poseidon::poseidon_m31::*;
use circuit_std_rs::poseidon::utils::*;
use circuit_std_rs::utils::register_hint;
use expander_compiler::frontend::*;
use mersenne31::M31;

// Reuse shared types and functions from bench module
pub use crate::bench::{M31SingleConfig, get_constraints, prove, verify};

// Includes the circuits that were generated by '../build.rs'
include!(concat!(env!("OUT_DIR"), "/poseidon_sizes.rs"));

pub fn check_poseidon<C: Config, B: RootAPI<C>>(api: &mut B, data: &[Variable]) -> Vec<Variable> {
    let msg_len = data.len() - OUTPUT_LEN;
    let inputs = &data[..msg_len];
    let expected = &data[msg_len..];

    let params = PoseidonM31Params::new(
        api,
        POSEIDON_M31X16_RATE,
        16,
        POSEIDON_M31X16_FULL_ROUNDS,
        POSEIDON_M31X16_PARTIAL_ROUNDS,
    );
    let computed = params.hash_to_state(api, inputs);

    for i in 0..OUTPUT_LEN {
        api.assert_is_equal(computed[i], expected[i]);
    }
    computed
}

// Macro generating a match arm that prepares the circuit and witness for the given input size
macro_rules! prepare_arm {
    ($Circuit:ident, $LEN:expr) => {{
        let compile_result =
            compile(&$Circuit::<Variable>::default(), CompileOptions::default()).unwrap();

        const LEN: usize = $LEN;
        let inputs = utils::generate_poseidon_input_m31(LEN);

        let mut assignment = $Circuit::<M31>::default();
        for (i, input_val) in inputs.iter().enumerate().take(LEN) {
            assignment.input[i] = M31::from(*input_val);
        }

        for i in 0..OUTPUT_LEN {
            assignment.output[i] = M31::from(0u32);
        }

        let mut hint_registry = HintRegistry::<M31>::new();
        register_hint(&mut hint_registry);

        let witness = compile_result
            .witness_solver
            .solve_witness_with_hints(&assignment, &mut hint_registry)
            .unwrap();

        crate::bench::serialize_outputs(compile_result, witness)
    }};
}

/// Prepare the circuit and witness for the given input size
pub fn prepare(input_len: usize) -> (Vec<u8>, Vec<u8>) {
    match_poseidon_sizes!(input_len, prepare_arm)
}
